#!/usr/bin/env python3

import socket
import threading
import time
import json
import subprocess
import psutil
import scapy.all as scapy
from scapy.layers.inet import IP, TCP
import matplotlib.pyplot as plt
import numpy as np
from collections import defaultdict, deque
import argparse
import sys
import os
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.live import Live
from rich.layout import Layout
from rich.text import Text
import requests
import hashlib
import statistics

console = Console()


class NetworkAnalyzer:
    """Analyzes network traffic to demonstrate what can be observed"""

    def __init__(self):
        self.packets = []
        self.connections = defaultdict(list)
        self.timing_data = deque(maxlen=1000)
        self.size_data = deque(maxlen=1000)
        self.tor_traffic = []
        self.is_capturing = False

    def start_capture(self, interface="lo", duration=60):
        """Start packet capture on specified interface"""
        # Auto-detect interface if default doesn't work
        if interface == "lo":
            import platform

            if platform.system() == "Darwin":  # macOS
                interface = "lo0"
            elif platform.system() == "Windows":
                interface = "Loopback"

        console.print(
            f"[yellow]Starting packet capture on {interface} for {duration}s...[/yellow]"
        )

        def packet_handler(packet):
            if self.is_capturing:
                timestamp = time.time()

                if packet.haslayer(TCP):
                    src_ip = packet[IP].src if packet.haslayer(IP) else "Unknown"
                    dst_ip = packet[IP].dst if packet.haslayer(IP) else "Unknown"
                    src_port = packet[TCP].sport
                    dst_port = packet[TCP].dport
                    size = len(packet)

                    # Check if this looks like Tor traffic (common Tor ports)
                    tor_ports = [9050, 9051, 9150, 9151, 8080]
                    is_tor = src_port in tor_ports or dst_port in tor_ports

                    packet_info = {
                        "timestamp": timestamp,
                        "src_ip": src_ip,
                        "dst_ip": dst_ip,
                        "src_port": src_port,
                        "dst_port": dst_port,
                        "size": size,
                        "is_tor": is_tor,
                        "payload_size": (
                            len(packet[TCP].payload) if packet[TCP].payload else 0
                        ),
                    }

                    self.packets.append(packet_info)
                    self.timing_data.append(timestamp)
                    self.size_data.append(size)

                    if is_tor:
                        self.tor_traffic.append(packet_info)

                    # Track connections
                    conn_key = f"{src_ip}:{src_port}->{dst_ip}:{dst_port}"
                    self.connections[conn_key].append(packet_info)

        self.is_capturing = True

        try:
            scapy.sniff(iface=interface, prn=packet_handler, timeout=duration, store=0)
        except PermissionError:
            console.print(
                "[red]Permission denied. Run as root/administrator for packet capture.[/red]"
            )
            return False
        except OSError as e:
            if "No such device" in str(e) or "not found" in str(e):
                console.print(
                    f"[red]Interface '{interface}' not found. Try --interface with a valid interface name.[/red]"
                )
                console.print(
                    "[yellow]Available interfaces can be found with: ip addr show (Linux) or ifconfig (macOS)[/yellow]"
                )
            else:
                console.print(f"[red]Network error: {e}[/red]")
            return False
        except Exception as e:
            console.print(f"[red]Capture error: {e}[/red]")
            return False
        finally:
            self.is_capturing = False

        return True

    def analyze_traffic_patterns(self):
        """Analyze captured traffic for patterns"""
        if not self.packets:
            return {}

        analysis = {
            "total_packets": len(self.packets),
            "tor_packets": len(self.tor_traffic),
            "unique_connections": len(self.connections),
            "avg_packet_size": statistics.mean([p["size"] for p in self.packets]),
            "size_variance": (
                statistics.variance([p["size"] for p in self.packets])
                if len(self.packets) > 1
                else 0
            ),
            "timing_patterns": self._analyze_timing(),
            "size_patterns": self._analyze_sizes(),
            "connection_patterns": self._analyze_connections(),
        }

        return analysis

    def _analyze_timing(self):
        """Analyze timing patterns in traffic"""
        if len(self.timing_data) < 2:
            return {}

        intervals = []
        for i in range(1, len(self.timing_data)):
            intervals.append(self.timing_data[i] - self.timing_data[i - 1])

        return {
            "avg_interval": statistics.mean(intervals),
            "interval_variance": (
                statistics.variance(intervals) if len(intervals) > 1 else 0
            ),
            "min_interval": min(intervals),
            "max_interval": max(intervals),
            "regular_pattern_detected": self._detect_regular_pattern(intervals),
        }

    def _analyze_sizes(self):
        """Analyze packet size patterns"""
        if not self.size_data:
            return {}

        size_counts = defaultdict(int)
        for size in self.size_data:
            size_counts[size] += 1

        # Check for fixed-size patterns (indicating padding)
        common_sizes = sorted(size_counts.items(), key=lambda x: x[1], reverse=True)[:5]

        return {
            "unique_sizes": len(size_counts),
            "most_common_sizes": common_sizes,
            "size_distribution": dict(size_counts),
            "padding_detected": self._detect_padding(list(size_counts.keys())),
        }

    def _analyze_connections(self):
        """Analyze connection patterns"""
        conn_analysis = {}

        for conn, packets in self.connections.items():
            if len(packets) > 1:
                durations = []
                sizes = []

                for packet in packets:
                    sizes.append(packet["size"])

                start_time = min(p["timestamp"] for p in packets)
                end_time = max(p["timestamp"] for p in packets)
                duration = end_time - start_time

                conn_analysis[conn] = {
                    "packet_count": len(packets),
                    "duration": duration,
                    "total_bytes": sum(sizes),
                    "avg_packet_size": statistics.mean(sizes),
                    "is_tor_connection": any(p["is_tor"] for p in packets),
                }

        return conn_analysis

    def _detect_regular_pattern(self, intervals):
        """Detect if timing intervals show regular patterns"""
        if len(intervals) < 10:
            return False

        # Check for periodic patterns
        avg_interval = statistics.mean(intervals)
        tolerance = avg_interval * 0.1  # 10% tolerance

        regular_count = sum(
            1 for interval in intervals if abs(interval - avg_interval) < tolerance
        )

        return regular_count / len(intervals) > 0.7  # 70% regularity threshold

    def _detect_padding(self, sizes):
        """Detect if packet sizes indicate padding"""
        # Common padding sizes used by the messenger
        expected_sizes = [512, 1024, 2048, 4096]

        padded_count = sum(
            1 for size in sizes if any(abs(size - exp) < 50 for exp in expected_sizes)
        )

        return padded_count / len(sizes) > 0.5 if sizes else False


class TorAnalyzer:
    """Analyzes Tor-specific aspects"""

    def __init__(self):
        self.tor_processes = []
        self.hidden_services = []

    def detect_tor_processes(self):
        """Detect running Tor processes"""
        tor_processes = []

        try:
            for proc in psutil.process_iter(["pid", "name"]):
                try:
                    proc_info = proc.info
                    if (
                        proc_info
                        and proc_info.get("name")
                        and "tor" in proc_info["name"].lower()
                    ):
                        connections = []
                        listening_ports = []
                        cmdline = []

                        # Try to get additional info
                        try:
                            cmdline = proc.cmdline()
                        except (
                            psutil.NoSuchProcess,
                            psutil.AccessDenied,
                            psutil.ZombieProcess,
                        ):
                            cmdline = ["N/A"]

                        try:
                            # Get connections separately since it's not a basic attribute
                            # Use net_connections() to avoid deprecation warning
                            try:
                                connections = proc.net_connections()
                            except AttributeError:
                                # Fallback for older psutil versions
                                connections = proc.connections()

                            listening_ports = [
                                conn.laddr.port
                                for conn in connections
                                if hasattr(conn, "status") and conn.status == "LISTEN"
                            ]
                        except (
                            psutil.NoSuchProcess,
                            psutil.AccessDenied,
                            psutil.ZombieProcess,
                        ):
                            pass

                        tor_processes.append(
                            {
                                "pid": proc_info["pid"],
                                "name": proc_info["name"],
                                "cmdline": cmdline,
                                "connections": len(connections),
                                "listening_ports": listening_ports,
                            }
                        )
                except (
                    psutil.NoSuchProcess,
                    psutil.AccessDenied,
                    psutil.ZombieProcess,
                ):
                    continue
        except Exception as e:
            console.print(
                f"[yellow]Warning: Could not scan all processes: {e}[/yellow]"
            )

        self.tor_processes = tor_processes
        return tor_processes

    def check_tor_configuration(self):
        """Check Tor configuration for security settings"""
        config_analysis = {
            "tor_running": len(self.tor_processes) > 0,
            "multiple_instances": len(self.tor_processes) > 1,
            "listening_ports": [],
            "security_assessment": [],
        }

        for proc in self.tor_processes:
            config_analysis["listening_ports"].extend(proc["listening_ports"])

        # Security assessments
        if 9050 in config_analysis["listening_ports"]:
            config_analysis["security_assessment"].append(
                "SOCKS proxy detected on standard port"
            )

        if 9051 in config_analysis["listening_ports"]:
            config_analysis["security_assessment"].append(
                "Control port detected - potential security risk"
            )

        if len(set(config_analysis["listening_ports"])) > 2:
            config_analysis["security_assessment"].append(
                "Multiple Tor ports - possible custom configuration"
            )

        return config_analysis

    def test_tor_connectivity(self):
        """Test Tor connectivity and anonymity"""
        tests = {
            "socks_proxy_working": False,
            "ip_leak_test": None,
            "dns_leak_test": None,
            "circuit_info": None,
        }

        # Test SOCKS proxy
        try:
            import socks

            test_socket = socks.socksocket()
            test_socket.set_proxy(socks.SOCKS5, "127.0.0.1", 9050)
            test_socket.settimeout(10)
            test_socket.connect(("check.torproject.org", 80))
            test_socket.close()
            tests["socks_proxy_working"] = True
        except ImportError:
            console.print(
                "[yellow]PySocks not available for connectivity test[/yellow]"
            )
            tests["socks_proxy_working"] = False
        except Exception:
            tests["socks_proxy_working"] = False

        # IP leak test (simplified)
        try:
            # This would normally check if real IP is exposed
            tests["ip_leak_test"] = "No direct IP exposure detected in local traffic"
        except Exception:
            tests["ip_leak_test"] = "Could not perform IP leak test"

        return tests


class CorrelationAnalyzer:
    """Analyzes traffic for correlation attacks"""

    def __init__(self):
        self.traffic_windows = deque(maxlen=100)
        self.correlation_data = []

    def analyze_traffic_correlation(self, packets):
        """Analyze traffic for correlation patterns"""
        if len(packets) < 10:
            return {"status": "Insufficient data for correlation analysis"}

        # Group packets by time windows
        window_size = 5.0  # 5 second windows
        windows = defaultdict(list)

        for packet in packets:
            window = int(packet["timestamp"] / window_size)
            windows[window].append(packet)

        correlation_results = {
            "time_windows_analyzed": len(windows),
            "correlation_risk": "LOW",
            "patterns_detected": [],
            "recommendations": [],
        }

        # Analyze each window
        for window_id, window_packets in windows.items():
            if len(window_packets) > 1:
                # Check for burst patterns
                if len(window_packets) > 10:
                    correlation_results["patterns_detected"].append(
                        f"Traffic burst detected in window {window_id} ({len(window_packets)} packets)"
                    )
                    correlation_results["correlation_risk"] = "MEDIUM"

                # Check for size patterns
                sizes = [p["size"] for p in window_packets]
                if len(set(sizes)) == 1:  # All same size
                    correlation_results["patterns_detected"].append(
                        f"Uniform packet sizes in window {window_id}"
                    )

                # Check for timing regularity
                timestamps = sorted([p["timestamp"] for p in window_packets])
                if len(timestamps) > 2:
                    intervals = [
                        timestamps[i + 1] - timestamps[i]
                        for i in range(len(timestamps) - 1)
                    ]
                    if statistics.variance(intervals) < 0.1:  # Very regular timing
                        correlation_results["patterns_detected"].append(
                            f"Regular timing pattern in window {window_id}"
                        )
                        correlation_results["correlation_risk"] = "HIGH"

        # Generate recommendations
        if correlation_results["correlation_risk"] == "HIGH":
            correlation_results["recommendations"].extend(
                [
                    "Increase timing randomization",
                    "Implement more aggressive dummy traffic",
                    "Consider using traffic shaping",
                ]
            )
        elif correlation_results["correlation_risk"] == "MEDIUM":
            correlation_results["recommendations"].extend(
                ["Monitor for traffic bursts", "Ensure dummy traffic is active"]
            )
        else:
            correlation_results["recommendations"].append(
                "Current traffic patterns show good anonymity protection"
            )

        return correlation_results


class SecurityTester:
    """Main security testing orchestrator"""

    def __init__(self):
        self.network_analyzer = NetworkAnalyzer()
        self.tor_analyzer = TorAnalyzer()
        self.correlation_analyzer = CorrelationAnalyzer()
        self.results = {}

    def run_comprehensive_test(self, capture_duration=60, interface="lo"):
        """Run comprehensive security analysis"""
        console.print(
            Panel.fit(
                "[bold cyan]Anonymous Messenger Security Analysis[/bold cyan]\n"
                "[dim]Demonstrating anonymity and security measures[/dim]",
                title="PenTest Tool",
            )
        )

        # Phase 1: Tor Analysis
        console.print("\n[yellow]Phase 1: Tor Infrastructure Analysis[/yellow]")
        tor_processes = self.tor_analyzer.detect_tor_processes()
        tor_config = self.tor_analyzer.check_tor_configuration()
        tor_connectivity = self.tor_analyzer.test_tor_connectivity()

        self.results["tor_analysis"] = {
            "processes": tor_processes,
            "configuration": tor_config,
            "connectivity": tor_connectivity,
        }

        self._display_tor_results()

        # Phase 2: Network Traffic Capture
        console.print(
            f"\n[yellow]Phase 2: Network Traffic Analysis ({capture_duration}s)[/yellow]"
        )
        console.print("[dim]Capturing packets to analyze traffic patterns...[/dim]")

        capture_success = self.network_analyzer.start_capture(
            interface, capture_duration
        )

        if capture_success:
            traffic_analysis = self.network_analyzer.analyze_traffic_patterns()
            correlation_analysis = (
                self.correlation_analyzer.analyze_traffic_correlation(
                    self.network_analyzer.packets
                )
            )

            self.results["traffic_analysis"] = traffic_analysis
            self.results["correlation_analysis"] = correlation_analysis

            self._display_traffic_results()
            self._display_correlation_results()
        else:
            console.print(
                "[red]Traffic capture failed. Some analysis will be limited.[/red]"
            )

        # Phase 3: Security Assessment
        console.print("\n[yellow]Phase 3: Security Assessment[/yellow]")
        security_score = self._calculate_security_score()
        self.results["security_score"] = security_score

        self._display_security_assessment()

        return self.results

    def _display_tor_results(self):
        """Display Tor analysis results"""
        table = Table(title="Tor Infrastructure Analysis")
        table.add_column("Component", style="cyan")
        table.add_column("Status", style="green")
        table.add_column("Details", style="dim")

        tor_data = self.results["tor_analysis"]

        # Tor processes
        if tor_data["processes"]:
            for proc in tor_data["processes"]:
                table.add_row(
                    "Tor Process",
                    "✓ Running",
                    f"PID: {proc['pid']}, Ports: {proc['listening_ports']}",
                )
        else:
            table.add_row("Tor Process", "✗ Not Found", "No Tor processes detected")

        # Configuration
        config = tor_data["configuration"]
        status = "✓ Secure" if config["tor_running"] else "✗ Not Running"
        details = f"Ports: {config['listening_ports']}"
        table.add_row("Configuration", status, details)

        # Connectivity
        conn = tor_data["connectivity"]
        socks_status = "✓ Working" if conn["socks_proxy_working"] else "✗ Failed"
        table.add_row("SOCKS Proxy", socks_status, "Tor network connectivity")

        console.print(table)

    def _display_traffic_results(self):
        """Display traffic analysis results"""
        if "traffic_analysis" not in self.results:
            return

        analysis = self.results["traffic_analysis"]

        table = Table(title="Network Traffic Analysis")
        table.add_column("Metric", style="cyan")
        table.add_column("Value", style="green")
        table.add_column("Security Implication", style="yellow")

        table.add_row(
            "Total Packets", str(analysis["total_packets"]), "Traffic volume observable"
        )

        table.add_row(
            "Tor Packets", str(analysis["tor_packets"]), "Tor usage detectable"
        )

        table.add_row(
            "Avg Packet Size",
            f"{analysis['avg_packet_size']:.1f} bytes",
            "Size patterns may reveal padding",
        )

        if "timing_patterns" in analysis:
            timing = analysis["timing_patterns"]
            regular_pattern = "Yes" if timing.get("regular_pattern_detected") else "No"
            table.add_row(
                "Regular Timing",
                regular_pattern,
                "Regular patterns aid correlation attacks",
            )

        if "size_patterns" in analysis:
            sizes = analysis["size_patterns"]
            padding = "Yes" if sizes.get("padding_detected") else "No"
            table.add_row(
                "Padding Detected", padding, "Padding helps prevent size analysis"
            )

        console.print(table)

    def _display_correlation_results(self):
        """Display correlation analysis results"""
        if "correlation_analysis" not in self.results:
            return

        analysis = self.results["correlation_analysis"]

        # Risk level with color coding
        risk_colors = {"LOW": "green", "MEDIUM": "yellow", "HIGH": "red"}
        risk_color = risk_colors.get(analysis["correlation_risk"], "white")

        console.print(
            f"\n[bold]Correlation Attack Risk: [{risk_color}]{analysis['correlation_risk']}[/{risk_color}][/bold]"
        )

        if analysis["patterns_detected"]:
            console.print("\n[yellow]Patterns Detected:[/yellow]")
            for pattern in analysis["patterns_detected"]:
                console.print(f"  • {pattern}")

        if analysis["recommendations"]:
            console.print("\n[cyan]Recommendations:[/cyan]")
            for rec in analysis["recommendations"]:
                console.print(f"  • {rec}")

    def _calculate_security_score(self):
        """Calculate overall security score"""
        score = 100
        factors = []

        # Tor infrastructure (30 points)
        if "tor_analysis" in self.results:
            tor_data = self.results["tor_analysis"]
            if not tor_data["configuration"]["tor_running"]:
                score -= 30
                factors.append("Tor not running (-30)")
            elif not tor_data["connectivity"]["socks_proxy_working"]:
                score -= 15
                factors.append("Tor connectivity issues (-15)")

        # Traffic analysis (40 points)
        if "traffic_analysis" in self.results:
            analysis = self.results["traffic_analysis"]

            # Check for timing patterns
            if "timing_patterns" in analysis:
                if analysis["timing_patterns"].get("regular_pattern_detected"):
                    score -= 15
                    factors.append("Regular timing patterns detected (-15)")

            # Check for padding
            if "size_patterns" in analysis:
                if not analysis["size_patterns"].get("padding_detected"):
                    score -= 10
                    factors.append("No padding detected (-10)")

            # Check Tor usage
            if analysis["tor_packets"] == 0:
                score -= 15
                factors.append("No Tor traffic detected (-15)")

        # Correlation risk (30 points)
        if "correlation_analysis" in self.results:
            risk = self.results["correlation_analysis"]["correlation_risk"]
            if risk == "HIGH":
                score -= 30
                factors.append("High correlation risk (-30)")
            elif risk == "MEDIUM":
                score -= 15
                factors.append("Medium correlation risk (-15)")

        return {
            "score": max(0, score),
            "grade": self._score_to_grade(score),
            "factors": factors,
        }

    def _score_to_grade(self, score):
        """Convert score to letter grade"""
        if score >= 90:
            return "A"
        elif score >= 80:
            return "B"
        elif score >= 70:
            return "C"
        elif score >= 60:
            return "D"
        else:
            return "F"

    def _display_security_assessment(self):
        """Display final security assessment"""
        if "security_score" not in self.results:
            return

        score_data = self.results["security_score"]
        score = score_data["score"]
        grade = score_data["grade"]

        # Color code the grade
        grade_colors = {
            "A": "green",
            "B": "green",
            "C": "yellow",
            "D": "red",
            "F": "red",
        }
        grade_color = grade_colors.get(grade, "white")

        console.print(
            Panel.fit(
                (
                    f"[bold]Security Score: {score}/100[/bold]\n"
                    f"[bold]Grade: [{grade_color}]{grade}[/{grade_color}][/bold]\n\n"
                    f"[dim]Factors affecting score:[/dim]\n"
                    + "\n".join(f"• {factor}" for factor in score_data["factors"])
                    if score_data["factors"]
                    else "[green]No security issues detected[/green]"
                ),
                title="Security Assessment",
            )
        )

    def generate_report(self, filename="security_report.json"):
        """Generate detailed security report"""
        with open(filename, "w") as f:
            json.dump(self.results, f, indent=2, default=str)

        console.print(f"[green]Detailed report saved to {filename}[/green]")


def main():
    parser = argparse.ArgumentParser(description="Anonymous Messenger Security Tester")
    parser.add_argument(
        "--duration", type=int, default=60, help="Capture duration in seconds"
    )
    parser.add_argument(
        "--interface",
        type=str,
        default="lo",
        help="Network interface to monitor (auto-detects: lo0 on macOS, lo on Linux)",
    )
    parser.add_argument("--report", type=str, help="Save report to file")
    parser.add_argument("--quick", action="store_true", help="Quick test (30 seconds)")

    args = parser.parse_args()

    if args.quick:
        args.duration = 30

    # Check for root privileges for packet capture
    try:
        if os.geteuid() != 0:
            console.print(
                "[yellow]Warning: Not running as root. Packet capture may fail.[/yellow]"
            )
            console.print("[dim]Run with sudo for full functionality.[/dim]")
    except AttributeError:
        # Windows doesn't have geteuid
        console.print(
            "[yellow]Running on Windows - some features may be limited.[/yellow]"
        )

    tester = SecurityTester()

    try:
        results = tester.run_comprehensive_test(args.duration, args.interface)

        if args.report:
            tester.generate_report(args.report)

        console.print("\n[bold green]Security analysis complete![/bold green]")
        console.print(
            "[dim]This tool demonstrates what data is visible to network observers.[/dim]"
        )
        console.print(
            "[dim]The anonymous messenger's security measures help protect against these attacks.[/dim]"
        )

    except KeyboardInterrupt:
        console.print("\n[yellow]Analysis interrupted by user[/yellow]")
    except Exception as e:
        console.print(f"[red]Error during analysis: {e}[/red]")


if __name__ == "__main__":
    main()
